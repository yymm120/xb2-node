## 游览器的进程和线程
### 进程和线程的区别
- CPU - 计算机的核心，其负责承担计算机的计算任务（可以比喻为一个工厂）。

- 进程 - CPU资源分配的最小单位，是能拥有资源和独立运行的最小单位。（可以比喻为工厂车间，是一个工厂任务的环节）任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。

- 线程 - CPU调度的最小单位，是建立在进程基础上的一次程序运行单位，属于单个的程序执行流，是一个进程中代码的不同执行路线。（可以比喻为一个车间的工人组成的一个个任务小组，不同的执行流，协同完成一个任务）

总述
一个进程中可以拥有多个线程，同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）及一些进程级的资源。虽然不同进程之间也可以通信，不过代价较大。

### 浏览器是多进程的
浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu和内存）。
每打开一个Tab页，就创建了一个独立的浏览器进程，每个进程相互独立。（可以在Chrome的任务管理器上验证tab页进程）
1. 多进程的好处
不会因为一个tab页崩溃，导致其他tab页也被影响。
相对于线程，进程之间是不共享资源和地址空间的，所以也不会存在太多的安全问题。
2. 包含的进程种类
Browser进程——浏览器的主进程，负责协调、主控，只有一个
第三方插件进程——每种类型的插件对应一个进程，仅当使用该插件时才创建
GPU进程——最多一个，用于3D绘制等
浏览器渲染进程——负责页面的渲染

### Browser进程与渲染进程的通信
如果打开任务管理器，然后打开一个浏览器，就可以看到任务管理器中出现了两个进程，一个是主控进程，一个则是打开Tab页的渲染进程
整个过程如下：
```
1.Browser进程收到用户请求，首先需要获取页面内容，随后将该任务通过RendererHost接口传递给Render进程。
2.Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染。
3.渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染。
4.当然可能会有JS操作DOM（这样可能会造成回流并重绘）
5.最后Render进程将结果传递给Browser进程
6.Browser进程接收到结果并将结果绘制出来
```

### 渲染进程是多线程的
1. GUI渲染线程——负责渲染浏览器界面，解析HTML，CSS
2. 定时触发器线程——处理setInterval与setTimeout任务
3. 事件触发线程——处理事件消息，控制事件循环
4. 异步http请求线程——处理XMLHttpRequest异步请求

#### 线程之间的关系
gui渲染与JS运行互斥
由于js可以DOM，如果在修改这些元素属性同时渲染界面，那么渲染线程前后获得的元素数据就可能不一致了
由于gui渲染与JS都运行在渲染主线程上，因此为了防止渲染出现不可预期的结果，浏览器设置为互斥关系
js为什么会阻塞页面加载
由于gui渲染与JS都运行在渲染主线程上，当浏览器执行js程序的时候，GUI渲染会被保存在一个队列中，直到JS程序执行完成才会接着执行。
因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。
WebWorker与SharedWorker
WebWorker——运行在web后台的线程，相当于js引擎向浏览器申请开一个子线程，由浏览器所开的，完全受主线程控制，而且不能操作dom

SharedWorker——是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用

WebWorker与SharedWorker本质上就是进程和线程的区别，SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程


## javascript单线程，异步与执行机制
js的单线程模型与游览器的进程/线程息息相关，在了解js单线程与异步的时候，建议先看看这篇文章

### 为什么是单线程
由于js是可操作dom的，如果js是多线程，在多线程的交互下，处于界面中的dom节点就可能成为一个临界资源。
这个时候，如果两个线程同时操作一个dom，一个负责修改，一个负责删除，这时就会出现问题。
虽然可以通过锁来解决上面的问题，但为了避免因为引入了锁而带来更大的复杂性，js在最初就选择了单线程。
强调一下，这里的单线程指的是渲染主线程，因为js引擎是运行在其上的，js并没有单独的运行线程，下面强调的主线程均为游览器的渲染主线程，可以理解为js运行和页面渲染都是在这一个线程上工作。
### 为什么需要异步
由于js是可操纵dom的，如果在修改这些dom的同时渲染界面（即js引擎和blink引擎同时运行），那么渲染前后获得的元素数据就可能不一致了。
为了防止渲染出现不可预期的结果，浏览器将gui渲染与js运行设置为互斥关系，当js引擎执行时，gui渲染就会被挂起，等到js空闲时才会被执行。
所以，如果js执行时间过长（同步ajax），就会让页面卡死，造成渲染阻塞。因此，js的异步特性就显得很有必要了。

### 如何实现异步
通过事件驱动机制，来实现异步任务等待，同步任务先执行。
当js在主线程上执行完同步任务后，再自动去拿留待的异步任务去执行。

#### 执行机制
js执行涉及主线程和执行栈，所有的程序任务都会被放到执行栈中被js引擎执行。
js执行采用后进先出的原则。当函数执行的时候，会被添加到栈的顶部；当执行栈执行完后，就会从栈顶被移出，直到栈内被清空。
主线程上的程序执行，由js引擎负责；事件队列，由事件触发线程管理。
#### 事件驱动机制
- 事件驱动机制（event driven）通过事件队列（event queue）和事件循环（event loop）来实现。
- 事件队列（event queue），也称消息队列/任务队列，由异步I/O操作发起，里面存放着各种事件消息，这些消息都关联着回调函数。
 事件循环（event loop），是指主线程重复从消息队列中取消息、执行的过程，这些消息有些是js产生的，有些是页面加载，更新和网络请求产生的。

#### 任务类型
从执行时机的角度
同步任务，存放在执行栈中，会被主线程依次执行的任务
异步任务，存放在事件队列中，会在异步操作有了结果后，将注册回调放入这个队列，等待主线程空闲时，被拉取到执行栈中执行。（空闲时，意味着同步任务已被执行完，执行栈为空了）

从提供者的角度
宏任务（macrotask），由宿主环境提供——setTimeout，setInterval，setImmediate，I/O，UI rendering事件，postMessage，MessageChannel
微任务（microtask），由语言标准提供——Promise.then，process.nextTick，Object.observe(已废弃)，MutationObserver
#### 任务机制
所有同步任务在执行完之前，任何的异步任务是不会执行的。
```js
console.log("A");
setTimeout(function(){
console.log("B");
},0);
while(true){}
```
// 结果为A。因为同步任务被死循环卡住了，任务队列里的任务不会被主线程拉取进执行栈
每执行一个宏任务后，就会执行所有微任务。

为了使js任务与dom任务能够有序执行，会在一个task执行结束后，在下一个task执行开始前，对页面进行重新渲染 （task(宏->微)->render->task(宏->微)-->...）

#### 宏任务/微任务拓展
1个事件循环中，宏任务可以有多个，微任务只有1个。
以银行排号为例，1个柜台对应多个用户，每个用户都是1个宏任务，当用户办完(宏)主任务后，突然想到要办理很多(微)次任务，银行柜员会一次帮他解决所有需求，而不是让他重新排队

#### 执行机制详述
执行一个宏任务，主栈中没有就从事件队列中获取。
执行过程中如果遇到微任务，就将它添加到微任务的任务队列中。
宏任务执行完毕后，立即依次执行当前微任务队列中的所有微任务。
当微任务执行完毕，开始检查渲染，然后blink引擎接管渲染。
渲染完毕后，js引擎继续接管，开始下一个宏任务。
```js
console.log('1');
setTimeout(function() {
console.log('5');
Promise.resolve().then(function() {
console.log('6');
})
}, 0);
Promise.resolve().then(function() {
console.log('3');
}).then(function() {
console.log('4');
});
console.log('2');
```
// 1，2，3，4，5，6
// 第一轮任务中，宏任务为全局script（刚好处于执行栈内，不用在事件队列中取），所以先是1，2；
// 同时，由于执行过程中遇到了setTimeout，将其再放入宏任务队列，遇到了promise，将其放入微任务队列；
// 该轮宏任务执行完毕后，开始执行微任务，将微任务全部取出，一次执行，因此再是3，4；
// 开始第二轮任务，取出的宏任务为setTimeout回调，因此结果是5；
// 同时执行这轮宏任务回调时，又遇到promise，再将其放入微任务队列；
// 当这轮宏任务setTimeout回调结束后，立即刚才加入的微任务取出执行，因此结果为6；
api优先级顺序

html5新特性MutationObserver属于微任务，优先级小于Promise
html5新特性MessageChannel属于宏任务，优先级是：setImmediate->MessageChannel->setTimeout。
在node环境的微任务执行中，process.nextTick的优先级高于promise。
在node环境的宏任务执行中，setImmediate的优先级高于setTimeout。
Vue.nextTick实现

2.4版本时，Vue通过利用MutationObserver来模拟nextTick（MutationObserver为H5新特性，用于监听一个dom变动， 当dom对象树发生任何变动时，Mutation Observer会得到通知）
2.5版本开始，nextTick实现移除了MutationObserver的方式（兼容性原因）， 取而代之的是使用MessageChannel （当然，默认情况仍然是Promise，不支持才兼容的）
由于，js执行是单线程，在一个tick的过程中，可能会存在多次修改数据，vue会把这些数据修改先统一push到一个队列里，然后内部调用1次nextTick去更新视图。
因此，vue从数据改变到dom视图变化是需要在下一个tick才能完成的，这种数据驱动变化的原理符合游览器的原理（js运行和gui渲染互斥）和处理策略（task(宏->微)->render->task(宏->微)-->...）
最终，Vue.nextTick采取的策略是默认走 microtask，对于一些dom交互事件，如v-on绑定的事件回调函数的处理，会强制走macrotask。对于macrotask的执行，vue优先检测是否支持原生setImmediate（高版本游览器支持），不支持的话再去检测是否支持原生的MessageChannel，如果也不支持的话就会降级为setTimeout 0。